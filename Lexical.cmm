
/*
 *基本的にこのLexicalはchで処理を行うため、
 *nextchに常にトークンの先頭がくる設計になっている.
 *
 *特別な処理以外ではnextchの判定を行う事は
 *基本的にしないような設計にもなっているので注意.
 *
 */


#include <string.hmm>
#include <stdlib.hmm>
#include <stdio.hmm>
#include <ctype.hmm>

#include "Assemble.hmm"
#include "Lexical.hmm"
#include "Error.hmm"


// static変数
FILE fp;            /* Lexicalのファイルポインタ */
char ch;            /* 現在の文字 */
char nextch;        /* 1つ先の文字 */
int token_id;       /* トークン番号 */
boolean label;
char[] str = array(LENGTH);          /* つづりの記憶領域を生成 */

RsvWord[] rsvword = {
{ "NO",		LxNO }, 
{ "LD",		LxLD },
{ "ST", 	LxST }, 
{ "ADD", 	LxADD },
{ "SUB", 	LxSUB },
{ "CMP",	LxCMP },
{ "AND", 	LxAND }, 
{ "OR",   	LxOR },
{ "XOR", 	LxXOR }, 
{ "SHLA",  	LxSHLA },
{ "SHLL",	LxSHLL }, 
{ "SHRA",  	LxSHRA },
{ "SHRL", 	LxSHRL }, 
{ "JMP",  	LxJMP },
{ "JZ",		LxJZ }, 
{ "JC",   	LxJC },
{ "JM",		LxJM }, 
{ "CALL",  	LxCALL },
{ "JNZ",	LxJNZ}, 
{ "JNC",    LxJNC },
{ "JNM", 	LxJNM }, 
{ "IN",     LxIN },
{ "OUT", 	LxOUT }, 
{ "PUSH",  	LxPUSH },
{ "PUSHF",	LxPUSHF }, 
{ "POP", 	LxPOP },
{ "POPF", 	LxPOPF }, 
{ "EI",		LxEI },
{ "DI",		LxDI }, 
{ "RET",	LxRET },
{ "RETI",	LxRETI }, 
{ "HALT",	LxHALT },
{ "EQU",	LxEQU }, 
{ "ORG",	LxORG },
{ "DS",		LxDS }, 
{ "DC",		LxDC },

{ "G0",		LxG0 }, 
{ "G1",		LxG1 },
{ "G2",		LxG2 }, 
{ "SP",		LxSP }
};

/*********** 予約語トークン番号を探す関数 **********/
int searchRsvWord(char[] word){
    int i;
    
    for(i = 0; i < LxRSV_NUM; i = i+1){
        if(strCmp(word,rsvword[i].token) == 0){
            token_id = rsvword[i].rsvword_id;
            return token_id;
        }
    }

    return token_id;
}

/******** 次の文字を取ってきて行を1行進める関数 *********/
public char getCh() {
    ch = nextch;                                /* 次の文字を現在の文字にする */
    if(feof(sourcefp)) {                        /* 次の入力がEOFなら */
        nextch = EOF;                           /* nextchにEOFの目印を */
    } else {                                    /* そうでなければ */
        nextch = toUpper(fgetc(sourcefp));      /* nextchに次の文字を読み込む */

        if(nextch==EOF)                         /* nextchにEOFが読み込まれていたら */
            error("input has '\x7f'");          /* 入力にEOFをがあるエラーを出力 */
    }

    return ch;                                  /* 現在の文字を返す */
}

/********** 改行か文字がくるまで空白を読み飛ばす関数 *************/
void skipSpaces() {
    while(nextch != '\n' && isSpace(nextch)){               /* 改行以外かつ空白なら */
        getCh();                                    /* 1文字読み飛ばす */
    }
}

/*************** 行末まで読み飛ばす関数 *******************/
public void skipToNewLineOrEOF() {
    while(ch != '\n' && ch != EOF){                 /* 改行かEOFが来るまで */
        getCh();                                    /* 1文字読み飛ばす */
    }
}

/*********** C++タイプのコメントを読み飛ばす関数 ***********/
void skipCppCom() {
    skipToNewLineOrEOF();                           /* 改行またはEOFまで読み飛ばす */
}

/************** コメント、空白を読み飛ばす **************/
void skipAllSpaces() {
    while(true) {
        skipSpaces();                               /* 改行以外の空白を飛ばす */
        if(ch == '/' && nextch == '/') {            /* "//"ならコメント開始 */
            skipCppCom();                           /* コメントを読み飛ばす */
        } else if(nextch == '\n') {
            break;
        } else{ 
            break;                                  /* "//",'\n'以外なら抜け出す */
        }
    }
}

/********************** 8進数字かテスト ****************************/
boolean isOdigit(char ch) {
  return ord('0') <= ord(ch) && ord(ch) <= ord('7'); // '0'〜'7'が8進数
}

/**********************  16進数字の値を返す ******************/
int hex(char ch) {
  if (isDigit(ch)) return ord(ch) - ord('0');      // '0'〜'9'の場合
  ch = toUpper(ch);                                // 英字は大文字に統一
  return ord(ch) - ord('A') + 10;                  // 'A'〜'F'の場合
}

/*******************  16進数を読んで値を返す ******************/
int getHex() {
  if (!isXdigit(ch))                               // 0x の次に16進数がない
    error("16進数の形式");
  int v = 0;                                       // 初期値は 0
  while (isXdigit(ch)) {                           // 16進数字の間
    v = v*16 + hex(ch);                            // 値を計算
    getCh();                                       // 次の文字を読む
  }
  return v;                                        // 16進数の値を返す
}

/*******************  8進数を読んで値を返す *******************/
int getOct() {
  int val = 0;                                     // 初期値は 0
  while (isOdigit(ch)) {                           // 8進数字の間
    val = val*8 + ord(ch) - ord('0');              // 値を計算
    getCh();                                       // 次の文字を読む
  }
  return val;                                      // 8進数の値を返す
}

/****************** 10進数を読んで値を返す ********************/
int getDec() {
  int val = 0;                                     // 初期値は 0
  while (isDigit(ch)) {                            // 10進数字の間
    val = val*10 + ord(ch) - ord('0');             // 値を計算
    getCh();                                       // 次の文字を読む
  }
  return val;						                           // 10進数の値を返す
}

/******************* 数値を読み込む ***********************/
public int getDigit() {
  int val = 0;
  if(ch=='0' && (nextch=='x' || nextch=='X')) {    // '0x' で始まれば16進数
    getCh();                                       // '0'を読み飛ばす
    getCh();                                       // 'x'を読み飛ばす
    val = getHex();                                // 16進数の読み込み
  } else if(ch=='0') {                             // '0' で始まれば8進数
    val = getOct();                                // 8進数を読み込む
  } else {                                         // それ以外は10進のはず
    val = getDec();                                // 10進数を読み込む
  }
  return val;                                      // val=値
}


/************* 文字列を読んでstrに設定する ************/
void getString(){
    str[0] = ch;            /* strに頭文字を記憶*/
    int i;                  /* strの添字用変数を宣言 */

    for(i = 1; isAlnum(nextch) == true; i = i+1){   /* chが英字もしくは数字なら */
        getCh();            /* 次の文字を取ってくる */
        str[i] = ch;        /* chをstrに記憶 */
    }

    str[i] = '\0';

}

/************* 文字列を取ってきてstrに格納する関数 ***********/
int getWord(){
    getString();                           /* strに文字列を取ってくる */
    
    token_id = searchRsvWord(str);      /* トークンが予約語と一致するか確認 */
    
    if(0 <= token_id && token_id < LxRSV_NUM){    /* token_idが予約語なら */
        return token_id;                                 /* token_idを返す */
    } else {                                             /* token_idが予約語以外なら */
        return LxNAM;                                    /* ラベルであることを返す */
    }
    
    return token_id;
}

/********* ラベルの有無を返す **********/
public boolean getLabel(){
    printf("start getLabel()\n");
    if( ch == '\0'){    /* まだ一度も文字を取ってきていない場合は */
        getCh();        /* chにはnextchの改行をnextchには文字の先頭を取ってくる */
    }

    if(ch == '\n' && nextch == ' '){        /* 行頭が空白なら */
        printf("label = false\n");
        label = false;
        return label;                       /* ラベルなしなのでfalse */
    } else if(ch == '\n' && isAlpha(nextch)){  /* 行頭がアルファベットなら */
        printf("label = true\n");
        label = true;
        return label;                        /* ラベルがあるのでtrue */
    } else{                                 /* それ以外なら */
        ;                                   /* エラー */
    }

    return false;
}

/********* 次のトークンを読んでトークン番号を返す関数 **********/
public int getToken(){
    printf("start getToken()\n");
    token_id = -1;          /* トークンを初期化 */

    if(ch == '\0'){         /* まだ一度も文字を取ってきていない場合は */
        getCh();        /* ch にはnextchの改行をnextchに文字の行頭を取ってくる */
    }

    getCh();

    if(ch == ' '){
        skipSpaces();
        return  LxSPC;
    } else if(ch == '"'){                  /* 文字列であるなら */
    printf("STRING\n");
        token_id = LxSTR;          /* トークン番号(文字列)を設定 */
    } else if(ch == '\''){           /* 文字定数であるなら */
    printf("NUMBER\n");
        token_id = LxNUM;           /* トークン番号(数値)を設定 */
    } else if(ch == '\n'){          /* 改行であるなら */
    printf("EOL\n");
        token_id = LxEOL;           /* トークン番号(改行)を返す */
        return LxEOL;               /* 改行だけはスペースを飛ばさないまま返す */
    } else if(ch == EOF){           /* EOFなら */
    printf("EOF\n");
        token_id = LxEOF;               /* トークン番号(EOF)を設定 */
    } else if(ch == '('){           /* 左括弧なら */
    printf("LBR\n");
        token_id = LxLBR;
    } else if(ch == ')'){           /* 右括弧なら */
    printf("RBR\n");
        token_id = LxRBR;
    } else if(ch == ','){           /* カンマなら */
    printf("COMMA\n");
        token_id = LxCMM;         /* トークン番号(カンマ)を設定 */
    } else if(ch == ';'){           /* セミコロンなら */
    printf("COMMENT\n");
        token_id = LxCOM;        /* トークン番号(セミコロン)を設定 */
    } else if(ch == '+'){           /* プラスなら */
    printf("PLUS\n");
        token_id = LxPLS;          /* トークン番号(プラス)を設定 */
    } else if(ch == '-'){           /* マイナスなら */
    printf("MINUS\n");
        token_id = LxMNS;         /* トークン番号(マイナス)を設定 */
    } else if(ch == '*'){           /* 乗算なら */
    printf("MULTIPUL\n");
        token_id = LxMUL;      /* トークン番号(乗算)を設定 */
    } else if(ch == '/'){           /* 除算なら */
    printf("DIVIDE\n");
        token_id = LxDIV;        /* トークン番号(除算)を設定 */
    } else if(ch == '#'){           /* イミディエイトなら */
    printf("IMM\n");
        token_id = LxIMM;         /* トークン番号(イミディエイト)を設定 */
    } else if(isAlpha(ch)){         /* chがアルファベットなら */
        token_id = getWord();       /* トークン番号(予約語かラベル)を返す */
    } else if(isDigit(ch)){         /* 数値であるなら */
    printf("NUMBER\n");
        getString();
        token_id = LxNUM;         /* トークン番号(数値)を設定 */
    } else{                         /* エラーなら */
        printf("error\n");          /* エラー */
        token_id = -1;              // とりあえず終了するために代用
    }
    
    printf("token_id = %d, str = %s\n",token_id,str);
    skipSpaces();
    return token_id;                /* トークン番号を返す */
}

/******* strを取ってくる関数 *********/
public char[] getLxStr(){
    return str;
}

/************** Lexicalのファイルポインタを設定 ***************/
public void setLxFp(FILE file){
    fp = file;
}

/******** Lexicalの初期化関数 *******/
public void initLexical() {
    ch = '\0';                          /* 現在の文字を初期化 */
    nextch = '\n';                      /* 次の文字の初期化 */
    token_id = -1;                      /* トークン番号の初期化 */
    str[0] = '\0';                         /* strの初期化 */
}
