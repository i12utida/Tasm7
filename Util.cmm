
/*
 * eqAnalyzer()はgetToken()を使うため、
 * Passとのトークン番号にズレが生じることに注意すること.
 *
 * また、そのズレを修正するため、
 * getTokenIDによってLexicalの現在のトークン番号を
 * 取ってこれるように設計してある.

 * eqAnalyzer()を使った場合はgetTokenIDを必ず使うこと.
 */

#include <stdio.hmm>
#include <stdlib.hmm>
#include <string.hmm>

#include "Util.hmm"
#include "Lexical.hmm"
#include "SymTbl.hmm"
#include "Editor.hmm"

/**** static変数 ****/
char[] str = array(LENGTH);
char[] hex = array(4);
int token_id;
int factor();
int term();
int expression();

/*
 * <因子１> ::= <因子> | + <因子> | - <因子>
 * <因子> ::= <数値> | <ラベル> | ( <式> )
 */
int factor(){
    int v = 0;
    
    /* 因子１ */
    if(token_id==LxPLS){              // 正の数なら
	    setOpr("+");                // アセンブルリスト用
	    token_id = getToken();      // 次のトークンを取ってくる
    } else if(token_id==LxMNS){       // 負の数
	    v = -1;                     // 
	    setOpr("-");                // アセンブルリスト用
	    token_id = getToken();
    }

    /* 因子 */
    if(token_id==LxNUM){                    // 数値（10進数, 16進数, 文字定数）
	    v = getDigit();                     // トークンの数値を取ってくる
        //printf(" factor v = *%d*\n",v);
	    setOpr(getLxStr());                 // オペランド配列に登録
    } else if(token_id==LxNAM){             // ラベル
        //printf("eqAnalyzer NAM getLxStr() *%s*\n",getLxStr());
	    int i = getLabelAddr(getLxStr());   // ラベルのアドレスを取ってくる
        //printf("factor i = *%d*\n",i);
	    setOpr(getLxStr());                 // アセンブルリストに登録
	    if(i == -1){                        // ラベルが登録されてない
            //printf("can't find label\n");
	        exit(1);                        // ラベルがないというエラー処理
	    } else{
	        v = v + i;                      // ラベルのアドレスを足す
            //printf("factor of NAM value = *%d*\n",v);
	    }
    } else if(token_id==LxLBR){             // 左括弧だったら
	    setOpr("(");                        // アセンブルリスト用
	    token_id = getToken();
	    v = expression();                   // 式を計算
	    if(token_id!=LxRBR){                // 右括弧以外なら
            //printf("can't find )\n");
            exit(1);                        // エラー処理
	    }
	    setOpr(")");                        // アセンブルリスト用
    } else{
        //printf("bad expression\n");
        exit(1);                            // 式が不正であるエラー処理
    }

    //printf("End of factor getToken()\n");
    token_id = getToken();                  // 次のトークンを取ってきておく
    return v;                               // 結果を返す
}

/*
 * <項> ::= <因子１> * <項> | <因子１> / <項> | <因子１>
 */
int term(){
    int v = factor();                           // <因子1>,<因子>の解析を呼び出す
    while(token_id==LxMUL || token_id==LxDIV){      // 乗算,除算の間
	    if(token_id==LxMUL){                      // 乗算なら
	        setOpr("*");                        // アセンブルリスト用
	        token_id = getToken();              // 次のトークンを取ってくる
	        v = v * factor();                   // <因子1>,<因子>の解析結果との乗算
	    }
	    else{                                   // 除算なら
	        setOpr("/");                        // アセンブルリスト用
	        token_id = getToken();              // 次のトークンを取ってくる
	        v = v / factor();                   // <因子1>,<因子>の解析結果と除算
	    }
    }
    return v;                                   // 結果を返す
}

/*
 * <式> ::= <項> + <式> | <項> - <式> | <項>
 */
int expression(){
    int v = term();                         // <項>の解析を呼び出す
    
    while(token_id==LxPLS || token_id==LxMNS){  // 加算,減算の間
	    if(token_id==LxPLS){                  // 加算なら
	        setOpr("+");                    // アセンブルリスト用
	        token_id = getToken();          // 次のトークンを取ってくる
	        v = v + term();                 // <項>の解析結果と加算
	    } else{                             // 減算なら
	        setOpr("-");                    // アセンブルリスト用
	        token_id = getToken();          // 次のトークンを取ってくる
	        v = v - term();                 // <項>の解析を呼び出す
	    }
    }
    return v;                       // 結果を返す
}


public int address1Analyzer(){
    //printf("address1Analyzer()\n");
    int value;
    token_id = getTokenID();        /* 現在のトークン番号を取ってくる */
    if(token_id == LxIMM){          /* イミディエイトなら */
        setOpr("#");                    /* '#'をセット */
        token_id = getToken();          /* <式>の部分を取ってくる */
        value = eqAnalyzer();           /* 式の解析を行い、結果を取ってくる */
        return value;                   /* 結果を返す */
    } else{                         /* インデクスドの場合 */
        value = eqAnalyzer();           /* 式の解析を行う */
        return value;                   /* 結果を返す */
    }
    
    return -1;                      /* エラーの場合はこれを返す */
}

/************* *実行しない ********************

public int address2Analyzer(){

}

public int valueAnalyzer(){
    
}
***********************************************/

public int eqAnalyzer(){
    //printf("eqAnalyzer()\n");
    int value;
    token_id = getTokenID();        /* 現在のトークン番号を取ってくる */
    //printf("eqAnalyzer token_id = *%d*\n",token_id);
    value = expression();           /* 式の解析を開始 */
    //printf("Return eqAnalyzer value = *%d*   token_id = *%d*\n",value,token_id);
    return value;
}

/************** 16進数値を16進文字列に変換 *************/
public char[] toHex(int digit){
    //printf("START toHex()  digit = *%d*\n",digit);
    int i1;
    int i2;

    i1 = digit/16;
    i2 = digit%16;

    //printf("i1 = *%d*,  i2 = *%d*\n",i1,i2);

    if(i1 < 10){
        hex[0] =chr( ord('0') + i1);
    } else{
        hex[0] =chr(ord('A') + i1-10);
    }

    if(i2 < 10){
        hex[1] = chr(ord('0') + i2);
    } else{
        hex[1] = chr(ord('A') + i2-10);
    }
    
    hex[2] = 'H';
    hex[3] = '\0';


    return hex;
}
/******************************************************/

void setEqOpr(){
    str = getLxStr();
    setOpr(str);
}

public void ch(){
    printf("ch == *%c*, nextch = *%c*\n",gch(),gnextch());
}
