#include <stdio.hmm>
#include <stdlib.hmm>
#include <string.hmm>

#include "Util.hmm"
#include "Lexical.hmm"
#include "SymTbl.hmm"

char[] eq_str = array(LENGTH);
int token_id;
int factor();
int term();
int expression();

void setOpr(char[] str){
    ;
}

/*
 * <因子１> ::= <因子> | + <因子> | - <因子>
 * <因子> ::= <数値> | <ラベル> | ( <式> )
 */
int factor(){
    int v = 0;
    
    /* 因子１ */
    if(token_id==LxPLS){              // 正の数なら
	    setOpr("+");                // アセンブルリスト用
	    token_id = getToken();      // 次のトークンを取ってくる
    } else if(token_id==LxMNS){       // 負の数
	    v = -1;                     // 
	    setOpr("-");                // アセンブルリスト用
	    token_id = getToken();
    }

    /* 因子 */
    if(token_id==LxNUM){                    // 数値（10進数, 16進数, 文字定数）
	    v = getDigit();                     // トークンの数値を取ってくる
        printf(" factor v = *%d*\n",v);
	    setOpr(getLxStr());                 // オペランド配列に登録
    } else if(token_id==LxNAM){             // ラベル
	    int i = getLabelAddr(getLxStr());   // ラベルのアドレスを取ってくる
        printf("factor i = *%d*\n",i);
	    setOpr(getLxStr());                 // アセンブルリストに登録
	    if(i == -1){                        // ラベルが登録されてない
            printf("can't find label\n");
	        exit(1);                        // ラベルがないというエラー処理
	    } else{
	        v = v + i;                      // ラベルのアドレスを足す
            printf("factor of NAM value = *%d*\n",v);
	    }
    } else if(token_id==LxLBR){             // 左括弧だったら
	    setOpr("(");                        // アセンブルリスト用
	    token_id = getToken();
	    v = expression();                   // 式を計算
	    if(token_id!=LxRBR){                // 右括弧以外なら
            printf("can't find )\n");
            exit(1);                        // エラー処理
	    }
	    setOpr(")");                        // アセンブルリスト用
    } else{
        printf("bad expression\n");
        exit(1);                            // 式が不正であるエラー処理
    }

    printf("End of factor getToken()\n");
    token_id = getToken();                  // 次のトークンを取ってきておく
    return v;                               // 結果を返す
}

/*
 * <項> ::= <因子１> * <項> | <因子１> / <項> | <因子１>
 */
int term(){
    int v = factor();                           // <因子1>,<因子>の解析を呼び出す
    while(token_id==LxMUL || token_id==LxDIV){      // 乗算,除算の間
	    if(token_id==LxMUL){                      // 乗算なら
	        setOpr("*");                        // アセンブルリスト用
	        token_id = getToken();              // 次のトークンを取ってくる
	        v = v * factor();                   // <因子1>,<因子>の解析結果との乗算
	    }
	    else{                                   // 除算なら
	        setOpr("/");                        // アセンブルリスト用
	        token_id = getToken();              // 次のトークンを取ってくる
	        v = v / factor();                   // <因子1>,<因子>の解析結果と除算
	    }
    }
    return v;                                   // 結果を返す
}

/*
 * <式> ::= <項> + <式> | <項> - <式> | <項>
 */
int expression(){
    int v = term();                         // <項>の解析を呼び出す
    
    while(token_id==LxPLS || token_id==LxMNS){  // 加算,減算の間
	    if(token_id==LxPLS){                  // 加算なら
	        setOpr("+");                    // アセンブルリスト用
	        token_id = getToken();          // 次のトークンを取ってくる
	        v = v + term();                 // <項>の解析結果と加算
	    } else{                             // 減算なら
	        setOpr("-");                    // アセンブルリスト用
	        token_id = getToken();          // 次のトークンを取ってくる
	        v = v - term();                 // <項>の解析を呼び出す
	    }
    }
    return v;                       // 結果を返す
}


/* 実行しない
public int address1Analyzer(){

}

public int address2Analyzer(){

}

public int valueAnalyzer(){

}
*/

public int eqAnalyzer(){
    printf("eqAnalyzer()\n");
    int value;
    token_id = getTokenID();
    value = expression();
    printf("Return eqAnalyzer value = *%d*\n",value);
    return value;
}

/* 実行しない
public char[] toHex(int digit){

}

public void setEqStr(){

}
*/

public void ch(){
    printf("ch == *%c*, nextch = *%c*\n",gch(),gnextch());
}
